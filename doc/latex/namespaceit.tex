\hypertarget{namespaceit}{}\section{it Namespace Reference}
\label{namespaceit}\index{it@{it}}


Main namespace.  


\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespaceit_1_1help}{help}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{structit_1_1UnZip}{Un\+Zip}
\item 
class \hyperlink{classit_1_1Zip}{Zip}
\item 
class \hyperlink{classit_1_1ZipIter}{Zip\+Iter}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\auto \hyperlink{namespaceit_ae3e2b700f5c415f9716eeca77de40f4e}{operator+} (\hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ iter, int inc)
\begin{DoxyCompactList}\small\item\em \textquotesingle{}operator+\textquotesingle{} and \textquotesingle{}operator-\/\textquotesingle{} will call \textquotesingle{}operator+=\textquotesingle{} and \textquotesingle{}operator-\/=\textquotesingle{} for increment \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\auto \hyperlink{namespaceit_a5ff256dae1a1aa8e2831d30d60e0f78c}{operator-\/} (\hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ iter, int inc)
\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\auto \hyperlink{namespaceit_afcc29ebadd551765c7fffbb18b84adbf}{operator+} (const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter1, const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter2)
\begin{DoxyCompactList}\small\item\em Distance from two iterators. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\auto \hyperlink{namespaceit_aeb4599bb226f6b4819451b1f1bcd4493}{operator-\/} (const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter1, const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter2)
\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\bool \hyperlink{namespaceit_a35d7fe94abbbb906c0b65aabd31dbfd3}{operator==} (const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter1, const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter2)
\begin{DoxyCompactList}\small\item\em Comparisons. Only \textquotesingle{}operator==\textquotesingle{} and \textquotesingle{}operator$<$\textquotesingle{} are defined. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\bool \hyperlink{namespaceit_aa1ec126ca216c4ff8b511f7b2f1d1e68}{operator!=} (const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter1, const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter2)
\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\bool \hyperlink{namespaceit_a9667a596ccc9f03510373b78b8048512}{operator$<$} (const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter1, const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter2)
\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\bool \hyperlink{namespaceit_ae28db9a014731d151257e863f3d5a1d1}{operator$>$} (const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter1, const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter2)
\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\bool \hyperlink{namespaceit_a9e84d394dd1fe80b87302e9a0e292028}{operator$<$=} (const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter1, const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter2)
\item 
{\footnotesize template$<$typename T , typename... Iters$>$ }\\bool \hyperlink{namespaceit_a31f1d6d5066e50a2d93fac8597c53b1f}{operator$>$=} (const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter1, const \hyperlink{classit_1_1ZipIter}{Zip\+Iter}$<$ T, Iters... $>$ \&iter2)
\item 
{\footnotesize template$<$typename T , typename... Iterators$>$ }\\auto \hyperlink{namespaceit_ac53929012901097d70c031455ed71c3b}{zip\+Iter} (T \&\&t, Iterators \&\&...iterators)
\item 
{\footnotesize template$<$typename T , typename... Containers, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value, int $>$  = 0$>$ }\\auto \hyperlink{namespaceit_af56a1ed82f73fa9bf680152e3618eb7e}{zip} (T \&\&t, Containers \&\&...containers)
\item 
{\footnotesize template$<$typename T , typename... Containers, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value, int $>$  = 0$>$ }\\auto \hyperlink{namespaceit_ada609562dc2444e6d70e548cb1ea76c4}{zip\+Begin} (T \&\&t, Containers \&\&...containers)
\item 
{\footnotesize template$<$typename T , typename... Containers, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value, int $>$  = 0$>$ }\\auto \hyperlink{namespaceit_a7fb0f903c3b17faa075ebdb35d43dfeb}{zip\+End} (T \&\&t, Containers \&\&...containers)
\item 
{\footnotesize template$<$typename T , typename... Containers, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value, int $>$  = 0$>$ }\\auto \hyperlink{namespaceit_a1f0d50c802f7ebc349493c21667c366c}{zip\+All} (T \&\&t, Containers \&\&...containers)
\item 
{\footnotesize template$<$class F $>$ }\\auto \hyperlink{namespaceit_a92b0020c9422efb3954750c81d125db8}{un\+Zip} (F f)
\item 
{\footnotesize template$<$class Tuple , class Function , std\+::size\+\_\+t... Is$>$ }\\decltype(auto) \hyperlink{namespaceit_a618ba642582130926aaccb6fee373261}{un\+Zip} (Tuple \&\&tup, Function function, std\+::index\+\_\+sequence$<$ Is... $>$)
\item 
{\footnotesize template$<$class Tuple , class Function $>$ }\\decltype(auto) \hyperlink{namespaceit_a8e31b0601b19400150691b97a2f2b729}{un\+Zip} (Tuple \&\&tup, Function function)
\item 
{\footnotesize template$<$typename... Args$>$ }\\void \hyperlink{namespaceit_a5d544a80e0acee396db704952cec839a}{for\+Each} (Args \&\&...args)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Main namespace. 

\subsection{Function Documentation}
\index{it@{it}!for\+Each@{for\+Each}}
\index{for\+Each@{for\+Each}!it@{it}}
\subsubsection[{\texorpdfstring{for\+Each(\+Args \&\&...\+args)}{forEach(Args &&...args)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Args$>$ void it\+::for\+Each (
\begin{DoxyParamCaption}
\item[{Args \&\&...}]{args}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_a5d544a80e0acee396db704952cec839a}{}\label{namespaceit_a5d544a80e0acee396db704952cec839a}
This function makes a call to the for loop unpacking the parameters with the \textquotesingle{}un\+Zip\textquotesingle{} function. A thing to notice is that the function is actually the first parameter of the variadic arguments. The order is changed with the \textquotesingle{}\hyperlink{namespaceit_1_1help_a99e8e2c8ea28d4c67e335d64a67434fd}{help\+::reverse}\textquotesingle{} function. \index{it@{it}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!it@{it}}
\subsubsection[{\texorpdfstring{operator"!=(const Zip\+Iter$<$ T, Iters... $>$ \&iter1, const Zip\+Iter$<$ T, Iters... $>$ \&iter2)}{operator!=(const ZipIter< T, Iters... > &iter1, const ZipIter< T, Iters... > &iter2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ bool it\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter1, }
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_aa1ec126ca216c4ff8b511f7b2f1d1e68}{}\label{namespaceit_aa1ec126ca216c4ff8b511f7b2f1d1e68}
\index{it@{it}!operator+@{operator+}}
\index{operator+@{operator+}!it@{it}}
\subsubsection[{\texorpdfstring{operator+(\+Zip\+Iter$<$ T, Iters... $>$ iter, int inc)}{operator+(ZipIter< T, Iters... > iter, int inc)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ auto it\+::operator+ (
\begin{DoxyParamCaption}
\item[{{\bf Zip\+Iter}$<$ T, Iters... $>$}]{iter, }
\item[{int}]{inc}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_ae3e2b700f5c415f9716eeca77de40f4e}{}\label{namespaceit_ae3e2b700f5c415f9716eeca77de40f4e}


\textquotesingle{}operator+\textquotesingle{} and \textquotesingle{}operator-\/\textquotesingle{} will call \textquotesingle{}operator+=\textquotesingle{} and \textquotesingle{}operator-\/=\textquotesingle{} for increment 

\index{it@{it}!operator+@{operator+}}
\index{operator+@{operator+}!it@{it}}
\subsubsection[{\texorpdfstring{operator+(const Zip\+Iter$<$ T, Iters... $>$ \&iter1, const Zip\+Iter$<$ T, Iters... $>$ \&iter2)}{operator+(const ZipIter< T, Iters... > &iter1, const ZipIter< T, Iters... > &iter2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ auto it\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter1, }
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_afcc29ebadd551765c7fffbb18b84adbf}{}\label{namespaceit_afcc29ebadd551765c7fffbb18b84adbf}


Distance from two iterators. 

\index{it@{it}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!it@{it}}
\subsubsection[{\texorpdfstring{operator-\/(\+Zip\+Iter$<$ T, Iters... $>$ iter, int inc)}{operator-(ZipIter< T, Iters... > iter, int inc)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ auto it\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{{\bf Zip\+Iter}$<$ T, Iters... $>$}]{iter, }
\item[{int}]{inc}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_a5ff256dae1a1aa8e2831d30d60e0f78c}{}\label{namespaceit_a5ff256dae1a1aa8e2831d30d60e0f78c}
\index{it@{it}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!it@{it}}
\subsubsection[{\texorpdfstring{operator-\/(const Zip\+Iter$<$ T, Iters... $>$ \&iter1, const Zip\+Iter$<$ T, Iters... $>$ \&iter2)}{operator-(const ZipIter< T, Iters... > &iter1, const ZipIter< T, Iters... > &iter2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ auto it\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter1, }
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_aeb4599bb226f6b4819451b1f1bcd4493}{}\label{namespaceit_aeb4599bb226f6b4819451b1f1bcd4493}
\index{it@{it}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!it@{it}}
\subsubsection[{\texorpdfstring{operator$<$(const Zip\+Iter$<$ T, Iters... $>$ \&iter1, const Zip\+Iter$<$ T, Iters... $>$ \&iter2)}{operator<(const ZipIter< T, Iters... > &iter1, const ZipIter< T, Iters... > &iter2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ bool it\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter1, }
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_a9667a596ccc9f03510373b78b8048512}{}\label{namespaceit_a9667a596ccc9f03510373b78b8048512}
\index{it@{it}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!it@{it}}
\subsubsection[{\texorpdfstring{operator$<$=(const Zip\+Iter$<$ T, Iters... $>$ \&iter1, const Zip\+Iter$<$ T, Iters... $>$ \&iter2)}{operator<=(const ZipIter< T, Iters... > &iter1, const ZipIter< T, Iters... > &iter2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ bool it\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter1, }
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_a9e84d394dd1fe80b87302e9a0e292028}{}\label{namespaceit_a9e84d394dd1fe80b87302e9a0e292028}
\index{it@{it}!operator==@{operator==}}
\index{operator==@{operator==}!it@{it}}
\subsubsection[{\texorpdfstring{operator==(const Zip\+Iter$<$ T, Iters... $>$ \&iter1, const Zip\+Iter$<$ T, Iters... $>$ \&iter2)}{operator==(const ZipIter< T, Iters... > &iter1, const ZipIter< T, Iters... > &iter2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ bool it\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter1, }
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_a35d7fe94abbbb906c0b65aabd31dbfd3}{}\label{namespaceit_a35d7fe94abbbb906c0b65aabd31dbfd3}


Comparisons. Only \textquotesingle{}operator==\textquotesingle{} and \textquotesingle{}operator$<$\textquotesingle{} are defined. 

\index{it@{it}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!it@{it}}
\subsubsection[{\texorpdfstring{operator$>$(const Zip\+Iter$<$ T, Iters... $>$ \&iter1, const Zip\+Iter$<$ T, Iters... $>$ \&iter2)}{operator>(const ZipIter< T, Iters... > &iter1, const ZipIter< T, Iters... > &iter2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ bool it\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter1, }
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_ae28db9a014731d151257e863f3d5a1d1}{}\label{namespaceit_ae28db9a014731d151257e863f3d5a1d1}
\index{it@{it}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!it@{it}}
\subsubsection[{\texorpdfstring{operator$>$=(const Zip\+Iter$<$ T, Iters... $>$ \&iter1, const Zip\+Iter$<$ T, Iters... $>$ \&iter2)}{operator>=(const ZipIter< T, Iters... > &iter1, const ZipIter< T, Iters... > &iter2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iters$>$ bool it\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter1, }
\item[{const {\bf Zip\+Iter}$<$ T, Iters... $>$ \&}]{iter2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceit_a31f1d6d5066e50a2d93fac8597c53b1f}{}\label{namespaceit_a31f1d6d5066e50a2d93fac8597c53b1f}
\index{it@{it}!un\+Zip@{un\+Zip}}
\index{un\+Zip@{un\+Zip}!it@{it}}
\subsubsection[{\texorpdfstring{un\+Zip(\+F f)}{unZip(F f)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F $>$ auto it\+::un\+Zip (
\begin{DoxyParamCaption}
\item[{F}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_a92b0020c9422efb3954750c81d125db8}{}\label{namespaceit_a92b0020c9422efb3954750c81d125db8}
As in the \textquotesingle{}zip\+Iter\textquotesingle{} and \textquotesingle{}zip\textquotesingle{} cases, this function is much easier than to call than to instantiate the class. The first function gets only a function as parameter, and is intended to use in stl functions. The other two are for the for range loop, and gets a tuple as parameter as well. \index{it@{it}!un\+Zip@{un\+Zip}}
\index{un\+Zip@{un\+Zip}!it@{it}}
\subsubsection[{\texorpdfstring{un\+Zip(\+Tuple \&\&tup, Function function, std\+::index\+\_\+sequence$<$ Is... $>$)}{unZip(Tuple &&tup, Function function, std::index_sequence< Is... >)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Tuple , class Function , std\+::size\+\_\+t... Is$>$ decltype(auto) it\+::un\+Zip (
\begin{DoxyParamCaption}
\item[{Tuple \&\&}]{tup, }
\item[{Function}]{function, }
\item[{std\+::index\+\_\+sequence$<$ Is... $>$}]{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_a618ba642582130926aaccb6fee373261}{}\label{namespaceit_a618ba642582130926aaccb6fee373261}
\index{it@{it}!un\+Zip@{un\+Zip}}
\index{un\+Zip@{un\+Zip}!it@{it}}
\subsubsection[{\texorpdfstring{un\+Zip(\+Tuple \&\&tup, Function function)}{unZip(Tuple &&tup, Function function)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Tuple , class Function $>$ decltype(auto) it\+::un\+Zip (
\begin{DoxyParamCaption}
\item[{Tuple \&\&}]{tup, }
\item[{Function}]{function}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_a8e31b0601b19400150691b97a2f2b729}{}\label{namespaceit_a8e31b0601b19400150691b97a2f2b729}
\index{it@{it}!zip@{zip}}
\index{zip@{zip}!it@{it}}
\subsubsection[{\texorpdfstring{zip(\+T \&\&t, Containers \&\&...\+containers)}{zip(T &&t, Containers &&...containers)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Containers, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value, int $>$  = 0$>$ auto it\+::zip (
\begin{DoxyParamCaption}
\item[{T \&\&}]{t, }
\item[{Containers \&\&...}]{containers}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_af56a1ed82f73fa9bf680152e3618eb7e}{}\label{namespaceit_af56a1ed82f73fa9bf680152e3618eb7e}
\index{it@{it}!zip\+All@{zip\+All}}
\index{zip\+All@{zip\+All}!it@{it}}
\subsubsection[{\texorpdfstring{zip\+All(\+T \&\&t, Containers \&\&...\+containers)}{zipAll(T &&t, Containers &&...containers)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Containers, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value, int $>$  = 0$>$ auto it\+::zip\+All (
\begin{DoxyParamCaption}
\item[{T \&\&}]{t, }
\item[{Containers \&\&...}]{containers}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_a1f0d50c802f7ebc349493c21667c366c}{}\label{namespaceit_a1f0d50c802f7ebc349493c21667c366c}
\index{it@{it}!zip\+Begin@{zip\+Begin}}
\index{zip\+Begin@{zip\+Begin}!it@{it}}
\subsubsection[{\texorpdfstring{zip\+Begin(\+T \&\&t, Containers \&\&...\+containers)}{zipBegin(T &&t, Containers &&...containers)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Containers, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value, int $>$  = 0$>$ auto it\+::zip\+Begin (
\begin{DoxyParamCaption}
\item[{T \&\&}]{t, }
\item[{Containers \&\&...}]{containers}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_ada609562dc2444e6d70e548cb1ea76c4}{}\label{namespaceit_ada609562dc2444e6d70e548cb1ea76c4}
These are facilities for calling \textquotesingle{}zip\+Iter\textquotesingle{} more easily. You can simply pass a container (or a pointer) with a defined \textquotesingle{}{\bf std\+::begin}\textquotesingle{} or \textquotesingle{}{\bf std\+::end}\textquotesingle{} and it will call the proper function. The \textquotesingle{}zip\+All\textquotesingle{} returns a {\bf std\+::pair} containing both the begin and end of the iterators \index{it@{it}!zip\+End@{zip\+End}}
\index{zip\+End@{zip\+End}!it@{it}}
\subsubsection[{\texorpdfstring{zip\+End(\+T \&\&t, Containers \&\&...\+containers)}{zipEnd(T &&t, Containers &&...containers)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Containers, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value, int $>$  = 0$>$ auto it\+::zip\+End (
\begin{DoxyParamCaption}
\item[{T \&\&}]{t, }
\item[{Containers \&\&...}]{containers}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_a7fb0f903c3b17faa075ebdb35d43dfeb}{}\label{namespaceit_a7fb0f903c3b17faa075ebdb35d43dfeb}
\index{it@{it}!zip\+Iter@{zip\+Iter}}
\index{zip\+Iter@{zip\+Iter}!it@{it}}
\subsubsection[{\texorpdfstring{zip\+Iter(\+T \&\&t, Iterators \&\&...\+iterators)}{zipIter(T &&t, Iterators &&...iterators)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Iterators$>$ auto it\+::zip\+Iter (
\begin{DoxyParamCaption}
\item[{T \&\&}]{t, }
\item[{Iterators \&\&...}]{iterators}
\end{DoxyParamCaption}
)}\hypertarget{namespaceit_ac53929012901097d70c031455ed71c3b}{}\label{namespaceit_ac53929012901097d70c031455ed71c3b}
These are the functions that will actually be called instead of initializing the classes with cumbersome types. I used the first type separatelly because it is easier to defined constraints (the first element of a container cannot be a pointer) and forces the call with at least 1 element 